{"/home/travis/build/npmtest/node-npmtest-happypack/test.js":"/* istanbul instrument in package npmtest_happypack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-happypack/lib.npmtest_happypack.js":"/* istanbul instrument in package npmtest_happypack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_happypack = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_happypack = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-happypack/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-happypack && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_happypack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_happypack\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_happypack.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_happypack.rollup.js'] =\n            local.assetsDict['/assets.npmtest_happypack.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_happypack.__dirname + '/lib.npmtest_happypack.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyPlugin.js":"var fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar assert = require('assert');\nvar HappyThreadPool = require('./HappyThreadPool');\nvar HappyForegroundThreadPool = require('./HappyForegroundThreadPool');\nvar HappyFSCache = require('./HappyFSCache');\nvar HappyUtils = require('./HappyUtils');\nvar WebpackUtils = require('./WebpackUtils');\nvar OptionParser = require('./OptionParser');\nvar JSONSerializer = require('./JSONSerializer');\nvar SourceMapSerializer = require('./SourceMapSerializer');\nvar fnOnce = require('./fnOnce');\nvar pkg = require('../package.json');\n\nfunction HappyPlugin(userConfig) {\n  if (!(this instanceof HappyPlugin)) {\n    return new HappyPlugin(userConfig);\n  }\n\n  this.name = 'HappyPack';\n  this.state = {\n    started: false,\n    loaders: [],\n    baseLoaderRequest: '',\n    foregroundThreadPool: null,\n    verbose: false,\n    debug: false,\n  };\n\n  this.config = OptionParser(userConfig, {\n    id:                       { type: 'string', default: '1' },\n    compilerId:               { type: 'string', default: 'default' },\n    tempDir:                  { type: 'string', default: '.happypack' },\n    threads:                  { type: 'number', default: 3 },\n    threadPool:               { type: 'object', default: null },\n    cache:                    { type: 'boolean', default: true },\n    cachePath:                { type: 'string' },\n    cacheContext:             { type: 'object', default: {} },\n    cacheSignatureGenerator:  { type: 'function' },\n    verbose:                  { type: 'boolean', default: true },\n    verboseWhenProfiling:     { type: 'boolean', default: false },\n    debug:                    { type: 'boolean', default: process.env.DEBUG === '1' },\n    enabled:                  { type: 'boolean', default: true },\n    loaders:                  {\n      validate: function(value) {\n        if (!Array.isArray(value)) {\n          return 'Loaders must be an array!';\n        }\n        else if (value.length === 0) {\n          return 'You must specify at least one loader!';\n        }\n        else if (value.some(function(loader) {\n          return typeof loader !== 'string' && !loader.path && !loader.loader;\n        })) {\n          return 'Loader must have a @path or @loader property or be a string.'\n        }\n      },\n    }\n  }, \"HappyPack[\" + this.id + \"]\");\n\n  this.id = this.config.id;\n\n  HappyUtils.mkdirSync(this.config.tempDir);\n\n  return this;\n}\n\nHappyPlugin.prototype.apply = function(compiler) {\n  var that, engageWatchMode;\n\n  if (this.config.enabled === false) {\n    return;\n  }\n\n  that = this;\n\n  this.state.verbose = isVerbose(compiler, this);\n  this.state.debug = isDebug(compiler, this);\n\n  this.threadPool = this.config.threadPool || HappyThreadPool({\n    id: this.id,\n    size: this.config.threads,\n    verbose: this.state.verbose,\n    debug: this.state.debug,\n  });\n\n  this.cache = HappyFSCache({\n    id: this.id,\n    path: this.config.cachePath ?\n      path.resolve(this.config.cachePath.replace(/\\[id\\]/g, this.id)) :\n      path.resolve(this.config.tempDir, 'cache--' + this.id + '.json'),\n    verbose: this.state.verbose,\n    generateSignature: this.config.cacheSignatureGenerator\n  });\n\n  engageWatchMode = fnOnce(function() {\n    // Once the initial build has completed, we create a foreground worker and\n    // perform all compilations in this thread instead:\n    compiler.plugin('done', function() {\n      that.state.foregroundThreadPool = HappyForegroundThreadPool({\n        loaders: that.state.loaders,\n      });\n\n      that.state.foregroundThreadPool.start(that.config.compilerId, compiler, '{}', Function.prototype);\n    });\n\n    // TODO: anything special to do here?\n    compiler.plugin('failed', function(err) {\n      console.warn('fatal watch error!!!', err);\n    });\n  });\n\n  compiler.plugin('watch-run', function(_, done) {\n    if (engageWatchMode() === fnOnce.ALREADY_CALLED) {\n      done();\n    }\n    else {\n      that.start(compiler, done);\n    }\n  });\n\n  compiler.plugin('run', that.start.bind(that));\n\n  // cleanup hooks:\n  compiler.plugin('done', that.stop.bind(that));\n\n  if (compiler.options.bail) {\n    compiler.plugin('compilation', function(compilation) {\n      compilation.plugin('failed-module', that.stop.bind(that));\n    });\n  }\n};\n\nHappyPlugin.prototype.start = function(compiler, done) {\n  var that = this;\n\n  if (that.state.verbose) {\n    console.log('Happy[%s]: Version: %s. Using cache? %s. Threads: %d%s',\n      that.id, pkg.version,\n      that.config.cache ? 'yes' : 'no',\n      that.threadPool.size,\n      that.config.threadPool ? ' (shared pool)' : ''\n    );\n  }\n\n  async.series([\n    function normalizeLoaders(callback) {\n      var loaders = that.config.loaders;\n\n      assert(loaders && loaders.length > 0,\n        \"HappyPlugin[\" + that.id + \"]; you have not specified any loaders \" +\n        \"and there is no matching loader entry with this id either.\"\n      );\n\n      that.state.loaders = loaders.reduce(function(list, entry) {\n        return list.concat(WebpackUtils.normalizeLoader(entry));\n      }, []);\n\n      callback(null);\n    },\n\n    function resolveLoaders(callback) {\n      var loaderPaths = that.state.loaders.map(function(loader) {\n        return loader.path;\n      });\n\n      WebpackUtils.resolveLoaders(compiler, loaderPaths, function(err, resolvedPaths) {\n        if (err) return callback(err);\n\n        resolvedPaths.forEach(function (resolvedPath, index) {\n          var loader = that.state.loaders[index];\n          loader.path = resolvedPath;\n          loader.request = (loader.query) ? loader.path + loader.query : loader.path;\n        });\n\n        that.state.baseLoaderRequest = that.state.loaders.map(function(loader) {\n          return loader.path + (loader.query || '');\n        }).join('!');\n\n        callback();\n      });\n    },\n\n    function loadCache(callback) {\n      if (that.config.cache) {\n        that.cache.load({\n          loaders: that.state.loaders,\n          external: that.config.cacheContext\n        });\n      }\n\n      callback();\n    },\n\n    function launchAndConfigureThreads(callback) {\n      var serializedOptions;\n      var compilerOptions = HappyPlugin.extractCompilerOptions(compiler.options);\n\n      try {\n        serializedOptions = JSONSerializer.serialize(compilerOptions);\n      }\n      catch(e) {\n        console.error('Happy[%s]: Unable to serialize options!!! This is an internal error.', that.id);\n        console.error(compilerOptions);\n\n        return callback(e);\n      }\n\n      that.threadPool.start(that.config.compilerId, compiler, serializedOptions, callback);\n    },\n\n    function markStarted(callback) {\n      if (that.state.verbose) {\n        console.log('Happy[%s]: All set; signalling webpack to proceed.', that.id);\n      }\n\n      that.state.started = true;\n\n      callback();\n    }\n  ], done);\n};\n\nHappyPlugin.prototype.stop = function() {\n  assert(this.state.started, \"HappyPlugin can not be torn down until started!\");\n\n  if (this.config.cache) {\n    this.cache.save();\n  }\n\n  this.threadPool.stop(this.config.compilerId);\n};\n\nHappyPlugin.prototype.compile = function(loader, loaderContext, done) {\n  if (this.state.foregroundThreadPool) {\n    return compileInForeground.call(this, loader, loaderContext, done);\n  }\n  else {\n    return compileInBackground.call(this, loader, loaderContext, done);\n  }\n};\n\nHappyPlugin.prototype.generateRequest = function(resource) {\n  return this.state.baseLoaderRequest + '!' + resource;\n};\n\n// export this so that users get to override if needed\nHappyPlugin.SERIALIZABLE_OPTIONS = [\n  'amd',\n  'bail',\n  'cache',\n  'context',\n  'entry',\n  'externals',\n  'debug',\n  'devtool',\n  'devServer',\n  'loader',\n  'module',\n  'node',\n  'output',\n  'profile',\n  'recordsPath',\n  'recordsInputPath',\n  'recordsOutputPath',\n  'resolve',\n  'resolveLoader',\n  'target',\n  'watch',\n];\n\nHappyPlugin.extractCompilerOptions = function(options) {\n  var ALLOWED_KEYS = HappyPlugin.SERIALIZABLE_OPTIONS;\n\n  return Object.keys(options).reduce(function(hsh, key) {\n    if (ALLOWED_KEYS.indexOf(key) > -1) {\n      hsh[key] = options[key];\n    }\n\n    return hsh;\n  }, {});\n};\n\n// convenience accessor to relieve people from requiring the file directly:\nHappyPlugin.ThreadPool = HappyThreadPool;\n\nfunction isVerbose(compiler, plugin) {\n  return plugin.config.verbose && (\n    !compiler.options.profile ||\n    plugin.config.verboseWhenProfiling\n  );\n};\n\nfunction isDebug(compiler, plugin) {\n  return plugin.config.debug && (\n    !compiler.options.profile ||\n    plugin.config.verboseWhenProfiling\n  );\n};\n\nfunction compileInBackground(loader, loaderContext, done) {\n  var filePath = loaderContext.resourcePath;\n\n  if (!this.cache.hasChanged(filePath) && !this.cache.hasErrored(filePath)) {\n    var cached = readFromCache(this.cache, filePath);\n\n    return done(null, cached.sourceCode, cached.sourceMap);\n  }\n\n  if (this.state.debug) {\n    console.warn('File had changed, re-compiling... (%s)', filePath);\n  }\n\n  compileAndUpdateCache.call(this, this.threadPool, loader, loaderContext, done);\n}\n\n// compile the source using the foreground worker instead of sending to the\n// background threads:\nfunction compileInForeground(loader, loaderContext, done) {\n  compileAndUpdateCache.call(this, this.state.foregroundThreadPool, loader, loaderContext, done);\n}\n\nfunction readFromCache(cache, filePath) {\n  var cached = {};\n  var sourceCodeFilePath = cache.getCompiledSourceCodePath(filePath);\n  var sourceMapFilePath = cache.getCompiledSourceMapPath(filePath);\n\n  cached.sourceCode = fs.readFileSync(sourceCodeFilePath, 'utf-8');\n\n  if (HappyUtils.isReadable(sourceMapFilePath)) {\n    cached.sourceMap = SourceMapSerializer.deserialize(\n      fs.readFileSync(sourceMapFilePath, 'utf-8')\n    );\n  }\n\n  return cached;\n}\n\nfunction compileAndUpdateCache(threadPool, loader, loaderContext, done) {\n  var cache = this.cache;\n  var filePath = loaderContext.resourcePath;\n\n  threadPool.compile(loaderContext.remoteLoaderId, loader, {\n    loaders: this.state.loaders,\n    compiledPath: path.resolve(this.config.tempDir, cache.getCompiledSourceCodePath(filePath) || HappyUtils.generateCompiledPath(filePath)),\n    loaderContext: loaderContext,\n  }, function(result) {\n    var contents = fs.readFileSync(result.compiledPath, 'utf-8')\n    var compiledMap;\n\n    if (!result.success) {\n      cache.set(filePath, contents, null);\n\n      done(contents);\n    }\n    else {\n      cache.set(filePath, null, result.compiledPath);\n\n      compiledMap = SourceMapSerializer.deserialize(\n        fs.readFileSync(cache.getCompiledSourceMapPath(filePath), 'utf-8')\n      );\n\n      done(null, contents, compiledMap);\n    }\n  });\n};\n\nmodule.exports = HappyPlugin;\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyThreadPool.js":"var async = require('async');\nvar assert = require('assert');\nvar HappyRPCHandler = require('./HappyRPCHandler');\nvar HappyThread = require('./HappyThread');\n\n/**\n * Create a thread pool that can be shared between multiple plugin instances.\n *\n * @param {Object} config\n * @param {Number!} config.size\n *        The number of background threads to spawn for running loaders.\n *\n * @param {String?} config.id\n *        Used for prefixing the thread IDs. This is only used for logging\n *        purposes and does not affect the functionality.\n *\n * @param {Boolean?} [config.verbose=false]\n *        Allow this module and threads to log information to the console.\n *\n * @param {Boolean?} [config.debug=false]\n *        Allow this module and threads to log debugging information to the\n *        console.\n */\nmodule.exports = function HappyThreadPool(config) {\n  var rpcHandler = new HappyRPCHandler();\n\n  assert(!isNaN(config.size),\n    \"ArgumentError: HappyThreadPool requires a valid integer for its size, but got NaN.\"\n  );\n\n  assert(config.size > 0,\n    \"ArgumentError: HappyThreadPool requires a positive integer for its size \" +\n    \", but got {\" + config.size + \"}.\"\n  );\n\n  var threads = createThreads(config.size, rpcHandler, {\n    id: config.id,\n    verbose: config.verbose,\n    debug: config.debug,\n  });\n\n  var getThread = RoundRobinThreadPool(threads);\n\n  return {\n    size: config.size,\n\n    start: function(compilerId, compiler, compilerOptions, done) {\n      rpcHandler.registerActiveCompiler(compilerId, compiler);\n\n      async.parallel(threads.filter(not(send('isOpen'))).map(get('open')), function(err) {\n        if (err) {\n          return done(err);\n        }\n\n        async.parallel(threads.map(function(thread) {\n          return function(callback) {\n            thread.configure(compilerId, compilerOptions, callback);\n          }\n        }), done);\n      });\n    },\n\n    isRunning: function() {\n      return !threads.some(not(send('isOpen')));\n    },\n\n    compile: function(loaderId, loader, params, done) {\n      var worker = getThread();\n\n      rpcHandler.registerActiveLoader(loaderId, loader);\n\n      worker.compile(params, function() {\n        rpcHandler.unregisterActiveLoader(loaderId);\n\n        done.apply(null, arguments);\n      });\n    },\n\n    stop: function(compilerId) {\n      rpcHandler.unregisterActiveCompiler(compilerId);\n\n      if (!rpcHandler.isActive()) {\n        threads.filter(send('isOpen')).map(send('close'));\n      }\n    },\n  };\n}\n\nfunction createThreads(count, rpcHandler, config) {\n  var set = []\n\n  for (var threadId = 0; threadId < count; ++threadId) {\n    var fullThreadId = config.id ? [ config.id, threadId ].join(':') : threadId;\n    set.push(HappyThread(fullThreadId, rpcHandler, config));\n  }\n\n  return set;\n}\n\nfunction send(method) {\n  return function(receiver) {\n    return receiver[method].call(receiver);\n  };\n}\n\nfunction get(attr) {\n  return function(object) {\n    return object[attr];\n  };\n}\n\nfunction not(f) {\n  return function(x) {\n    return !f(x);\n  };\n}\n\nfunction RoundRobinThreadPool(threads) {\n  var lastThreadId = 0;\n\n  return function getThread() {\n    var threadId = lastThreadId;\n\n    lastThreadId++;\n\n    if (lastThreadId >= threads.length) {\n      lastThreadId = 0;\n    }\n\n    return threads[threadId];\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyRPCHandler.js":"var assert = require('assert');\nvar SourceMapSerializer = require('./SourceMapSerializer');\nvar SharedPtrMap = require('./SharedPtrMap');\nvar COMPILER_RPCs, LOADER_RPCS;\n\nfunction HappyRPCHandler() {\n  this.activeLoaders = new SharedPtrMap();\n  this.activeCompilers = new SharedPtrMap();\n}\n\nHappyRPCHandler.prototype.registerActiveCompiler = function(id, compiler) {\n  this.activeCompilers.set(id || 'default', compiler);\n};\n\nHappyRPCHandler.prototype.isActive = function() {\n  return this.activeCompilers.getSize() > 0;\n};\n\nHappyRPCHandler.prototype.unregisterActiveCompiler = function(id) {\n  this.activeCompilers.delete(id || 'default');\n};\n\nHappyRPCHandler.prototype.registerActiveLoader = function(id, instance) {\n  this.activeLoaders.set(id || '1', instance);\n};\n\nHappyRPCHandler.prototype.unregisterActiveLoader = function(id) {\n  this.activeLoaders.delete(id || '1');\n};\n\nHappyRPCHandler.prototype.execute = function(type, payload, done) {\n  var compiler, loader;\n\n  if (COMPILER_RPCs.hasOwnProperty(type)) {\n    if (payload.compilerId) {\n      compiler = this.activeCompilers.get(payload.compilerId);\n    }\n    else {\n      compiler = this.activeCompilers.get('default');\n    }\n\n    assert(!!compiler,\n      \"A compiler RPC was dispatched, but no compiler instance was registered!\"\n    );\n\n    COMPILER_RPCs[type](compiler, payload, done);\n  }\n  else if (LOADER_RPCS.hasOwnProperty(type)) {\n    loader = this.activeLoaders.get(payload.remoteLoaderId);\n\n    assert(!!loader,\n      \"A loader RPC was dispatched to HappyLoader[\" + payload.remoteLoaderId +\n      \"] but no such loader is active!\"\n    );\n\n    LOADER_RPCS[type](loader, payload, done);\n  }\n  else {\n    assert(false, \"Unrecognized loader RPC '\" + type + '\"');\n  }\n};\n\nCOMPILER_RPCs = {\n  resolve: function(compiler, payload, done) {\n    var resolver = compiler.resolvers.normal;\n    var resolve = compiler.resolvers.normal.resolve;\n\n    if (resolve.length === 4) {\n      resolve.call(resolver, payload.context, payload.context, payload.resource, done);\n    }\n    else {\n      resolve.call(resolver, payload.context, payload.resource, done);\n    }\n  },\n};\n\nLOADER_RPCS = {\n  emitWarning: function(loader, payload) {\n    loader.emitWarning(payload.message);\n  },\n\n  emitError: function(loader, payload) {\n    loader.emitError(payload.message);\n  },\n\n  emitFile: function(loader, payload) {\n    loader.emitFile(\n      payload.name,\n      payload.contents,\n      SourceMapSerializer.deserialize(payload.sourceMap)\n    );\n  },\n\n  addDependency: function(loader, payload) {\n    loader.addDependency(payload.file);\n  },\n\n  addContextDependency: function(loader, payload) {\n    loader.addContextDependency(payload.file);\n  },\n\n  clearDependencies: function(loader) {\n    loader.clearDependencies();\n  },\n\n  loadModule: function(loader, payload, done) {\n    loader.loadModule(payload.file, done);\n  },\n};\n\n\nmodule.exports = HappyRPCHandler;\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/SourceMapSerializer.js":"exports.serialize = function(x) {\n  if (typeof x === 'string') {\n    return x;\n  }\n  else {\n    return JSON.stringify(x || null);\n  }\n};\n\nexports.deserialize = function(x) {\n  if (typeof x === 'string') {\n    try {\n      return JSON.parse(x);\n    } catch (e) {\n      return null;\n    }\n  }\n  return x || null;\n};\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/SharedPtrMap.js":"var SharedPtr = require('./SharedPtr');\n\nfunction SharedPtrMap() {\n  this.map = {};\n}\n\nSharedPtrMap.prototype.set = function(key, value) {\n  if (!this.map.hasOwnProperty(key)) {\n    this.map[key] = new SharedPtr(value);\n  }\n  else {\n    this.map[key].acquire();\n  }\n};\n\nSharedPtrMap.prototype.get = function(key) {\n  return SharedPtr.safeGet(this.map[key]);\n};\n\nSharedPtrMap.prototype.getSize = function() {\n  return Object.keys(this.map).length;\n};\n\nSharedPtrMap.prototype.delete = function(key) {\n  if (this.map[key]) {\n    this.map[key].release();\n\n    if (this.map[key].isDead()) {\n      delete this.map[key];\n    }\n  }\n};\n\nmodule.exports = SharedPtrMap;","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/SharedPtr.js":"var assert = require('assert');\n\nfunction SharedPtr(value) {\n  this._refs = 1;\n  this._value = value;\n}\n\nSharedPtr.prototype.acquire = function() {\n  assert(this.hasOwnProperty('_value'), \"Invalid attempt to acquire a dangling pointer!\");\n\n  this._refs += 1;\n};\n\nSharedPtr.prototype.release = function() {\n  this._refs -= 1;\n\n  assert(this._refs >= 0,\n    \"Potential race condition or memory leak; shared pointer reference count \" +\n    \"has gone below zero! (\" + this._refs + \")\"\n  );\n\n  if (this._refs === 0) {\n    delete this._value;\n  }\n};\n\nSharedPtr.prototype.get = function() {\n  return this._value;\n};\n\nSharedPtr.prototype.isDead = function() {\n  return this._refs === 0;\n};\n\nSharedPtr.safeGet = function(ptr) {\n  return ptr && ptr.get() || null;\n};\n\nmodule.exports = SharedPtr;\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyThread.js":"var path = require('path');\nvar fork = require('child_process').fork;\nvar assert = require('assert');\nvar Once = require('./fnOnce');\nvar WORKER_BIN = path.resolve(__dirname, 'HappyWorkerChannel.js');\n\n/**\n * @param {String|Number} id\n * @param {Object?} config\n * @param {Boolean} [config.verbose=false]\n * @param {Boolean} [config.debug=false]\n */\nfunction HappyThread(id, happyRPCHandler, config) {\n  config = config || {};\n\n  var fd;\n  var callbacks = {};\n  var generateMessageId = (function() {\n    var counter = 0;\n\n    return function() {\n      var nextId = ++counter;\n\n      return 'Thread::' + id.toString() + ':' + nextId.toString();\n    }\n  }());\n\n  return {\n    open: function(onReady) {\n      var emitReady = Once(onReady);\n\n      fd = fork(WORKER_BIN, [id], {\n        // Do not pass through any arguments that were passed to the main\n        // process (webpack or node) because they could have unwanted\n        // side-effects, see issue #47\n        execArgv: []\n      });\n\n      fd.on('error', throwError);\n      fd.on('exit', function(exitCode) {\n        if (exitCode !== 0) {\n          emitReady('HappyPack: worker exited abnormally with code ' + exitCode);\n        }\n      });\n\n      fd.on('message', function acceptMessageFromWorker(message) {\n        if (message.name === 'READY') {\n          if (config.debug) {\n            console.info('HappyThread[%s] is now open.', id);\n          }\n\n          emitReady();\n        }\n        else if (message.name === 'CONFIGURE_DONE') {\n          assert(typeof callbacks[message.id] === 'function',\n            \"HappyThread: expected plugin to be awaiting a configuration ACK.\"\n          );\n\n          callbacks[message.id]();\n          delete callbacks[message.id];\n        }\n        else if (message.name === 'COMPILED') {\n          var filePath = message.sourcePath;\n\n          if (config.debug) {\n            console.log('HappyThread[%s]: a file has been compiled. (request=%s)', id, filePath, message.id);\n          }\n\n          assert(typeof callbacks[message.id] === 'function',\n            \"HappyThread: expected loader to be pending on source file '\" +\n            filePath + \"'\" + \" (this is likely an internal error!)\"\n          );\n\n          callbacks[message.id](message);\n          delete callbacks[message.id];\n        }\n        else if (message.name === 'COMPILER_REQUEST') {\n          if (config.debug) {\n            console.log('HappyThread[%s]: forwarding compiler request from worker to plugin:', id, message);\n          }\n\n          // TODO: DRY alert, see .createForegroundWorker() in HappyPlugin.js\n          happyRPCHandler.execute(message.data.type, message.data.payload, function(error, result) {\n            // console.log('forwarding compiler response from plugin back to worker:', error, result);\n\n            fd.send({\n              id: message.id, // downstream id\n              name: 'COMPILER_RESPONSE',\n              data: {\n                compilerId: message.data.compilerId,\n                payload: {\n                  error: error || null,\n                  result: result || null\n                }\n              }\n            });\n          });\n        }\n      });\n    },\n\n    configure: function(compilerId, compilerOptions, done) {\n      var messageId = generateMessageId();\n\n      callbacks[messageId] = done;\n\n      fd.send({\n        id: messageId,\n        name: 'CONFIGURE',\n        data: {\n          compilerId: compilerId,\n          compilerOptions: compilerOptions\n        }\n      });\n    },\n\n    /**\n     * @param {Object} params\n     * @param {String} params.compiledPath\n     * @param {Object} params.loaderContext\n     *\n     * @param {Function} done\n     */\n    compile: function(params, done) {\n      var messageId = generateMessageId();\n\n      assert(params.compiledPath && typeof params.compiledPath === 'string');\n      assert(params.loaderContext && typeof params.loaderContext === 'object');\n\n      assert(!!fd, \"You must launch a compilation thread before attemping to use it!!!\");\n\n      callbacks[messageId] = done;\n\n      if (config.debug) {\n        console.log('HappyThread[%s]: compiling \"%s\"...', id, params.loaderContext.resourcePath);\n      }\n\n      fd.send({\n        id: messageId,\n        name: 'COMPILE',\n        data: params,\n      });\n    },\n\n    isOpen: function() {\n      return !!fd;\n    },\n\n    close: function() {\n      fd.kill('SIGINT');\n      fd = null;\n\n      if (config.debug) {\n        console.info('HappyThread[%s] is now closed.', id);\n      }\n    },\n  };\n}\n\nmodule.exports = HappyThread;\n\nfunction throwError(e) {\n  throw e;\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/fnOnce.js":"function Once(fn) {\n  var called = false;\n\n  return function() {\n    if (!called) {\n      called = true;\n      return fn.apply(null, arguments);\n    }\n    else {\n      return Once.ALREADY_CALLED;\n    }\n  }\n}\n\nOnce.ALREADY_CALLED = Object.freeze({});\n\nmodule.exports = Once;","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyForegroundThreadPool.js":"var HappyFakeCompiler = require('./HappyFakeCompiler');\nvar HappyRPCHandler = require('./HappyRPCHandler');\nvar HappyWorker = require('./HappyWorker');\n\n/**\n * Create a thread pool that can be shared between multiple plugin instances.\n *\n * @param {Object} config\n *\n * @param {Array.<String>} config.loaders\n *        The loaders to configure the (foreground) worker with.\n */\nfunction HappyForegroundThreadPool(config) {\n  var rpcHandler, worker;\n\n  return {\n    size: config.size,\n\n    start: function(compilerId, compiler, compilerOptions, done) {\n      var fakeCompiler = new HappyFakeCompiler({\n        id: 'foreground',\n        compilerId: compilerId,\n        send: function executeCompilerRPC(message) {\n          // TODO: DRY alert, see HappyThread.js\n          rpcHandler.execute(message.data.type, message.data.payload, function serveRPCResult(error, result) {\n            fakeCompiler._handleResponse(message.id, {\n              payload: {\n                error: error || null,\n                result: result || null\n              }\n            });\n          });\n        }\n      });\n\n      fakeCompiler.configure(compiler.options);\n\n      rpcHandler = new HappyRPCHandler();\n      rpcHandler.registerActiveCompiler(compilerId, compiler);\n\n      worker = new HappyWorker({\n        compiler: fakeCompiler,\n        loaders: config.loaders\n      });\n\n      done();\n    },\n\n    isRunning: function() {\n      return !!worker;\n    },\n\n    stop: function(/*compilerId*/) {\n      worker = null;\n      rpcHandler = null;\n    },\n\n    compile: function(loaderId, loader, params, done) {\n      rpcHandler.registerActiveLoader(loaderId, loader);\n\n      worker.compile(params, function() {\n        rpcHandler.unregisterActiveLoader(loaderId);\n\n        done.apply(null, arguments);\n      });\n    },\n  };\n}\n\nmodule.exports = HappyForegroundThreadPool;","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyFakeCompiler.js":"var assert = require('assert');\nvar fs = require('fs');\n\n/**\n * @param {String} params.id\n * @param {String} params.compilerId\n * @param {Function} params.send\n */\nfunction HappyFakeCompiler(params) {\n  assert(typeof params.id === 'string',\n    \"id must be assigned to a HappyFakeCompiler.\");\n\n  assert(typeof params.compilerId === 'string',\n    \"compilerId must be assigned to a HappyFakeCompiler.\");\n\n  assert(typeof params.send === 'function',\n    \"send implementation must be assigned to a HappyFakeCompiler.\");\n\n  this._id = 'FakeCompiler::' + params.id.toString() + '-' + params.compilerId.toString();\n  this._compilerId = params.compilerId;\n  this._sendMessageImpl = params.send;\n  this._requests = {};\n  this._messageId = 0;\n  this.options = {};\n  this.context = null;\n  this.inputFileSystem = fs;\n}\n\nvar HFCPt = HappyFakeCompiler.prototype;\n\nHFCPt.configure = function(compilerOptions) {\n  assert(compilerOptions && typeof compilerOptions === 'object');\n\n  this.options = compilerOptions;\n  this.context = compilerOptions.context;\n};\n\n/**\n * @public\n *\n * @param  {String}   context\n * @param  {String}   resource\n * @param  {Function} done\n *\n * @param {String} [done.error=null]\n *        A resolving error, if any.\n *\n * @param {String} done.filePath\n *        The resolved file path.\n */\nHFCPt.resolve = function(context, resource, done) {\n  this._sendMessage('resolve', {\n    context: context,\n    resource: resource\n  }, done);\n};\n\n// @private\nHFCPt._handleResponse = function(id, message) {\n  var callback;\n\n  if (!this._requests[id]) return; // not for us\n\n  assert(message.payload.hasOwnProperty('error'),\n    \"Compiler message payload must contain an @error field!\");\n\n  assert(message.payload.hasOwnProperty('result'),\n    \"Compiler message payload must contain a @result field!\");\n\n  callback = this._requests[id];\n  delete this._requests[id];\n\n  callback(message.payload.error, message.payload.result);\n};\n\n// @private\nHFCPt._sendMessage = function(type, payload, done) {\n  var messageId = this._id + ':' + (++this._messageId).toString();\n\n  this._requests[messageId] = done;\n  this._sendMessageImpl({\n    id: messageId,\n    name: 'COMPILER_REQUEST',\n    data: {\n      type: type,\n      compilerId: this._compilerId,\n      payload: payload,\n    }\n  });\n};\n\nmodule.exports = HappyFakeCompiler;","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyWorker.js":"var fs = require('fs');\nvar assert = require('assert');\nvar applyLoaders = require('./applyLoaders');\nvar serializeError = require('./serializeError');\nvar SourceMapSerializer = require('./SourceMapSerializer');\n\nfunction HappyWorker(params) {\n  this._compiler = params.compiler;\n}\n\n/**\n * @param  {Object} params\n * @param  {Object} params.loaderContext\n * @param  {String} params.loaderContext.resourcePath\n * @param  {String} params.compiledPath\n * @param  {Array.<String>} params.loaders\n * @param  {Function} done\n */\nHappyWorker.prototype.compile = function(params, done) {\n  assert(typeof params.loaderContext.resourcePath === 'string',\n    \"ArgumentError: expected params.sourcePath to contain path to the source file.\"\n  );\n\n  assert(typeof params.compiledPath === 'string',\n    \"ArgumentError: expected params.compiledPath to contain path to the compiled file.\"\n  );\n\n  assert(Array.isArray(params.loaders),\n    \"ArgumentError: expected params.loaders to contain a list of loaders.\"\n  );\n\n  applyLoaders({\n    compiler: this._compiler,\n    loaders: params.loaders,\n    loaderContext: params.loaderContext,\n  }, params.loaderContext.sourceCode, params.loaderContext.sourceMap, function(err, source, sourceMap) {\n    var compiledPath = params.compiledPath;\n    var success = false;\n\n    if (err) {\n      console.error(err);\n      fs.writeFileSync(compiledPath, serializeError(err), 'utf-8');\n    }\n    else {\n      fs.writeFileSync(compiledPath, source);\n      fs.writeFileSync(compiledPath + '.map', SourceMapSerializer.serialize(sourceMap));\n\n      success = true;\n    }\n\n    done({\n      sourcePath: params.loaderContext.resourcePath,\n      compiledPath: compiledPath,\n      success: success\n    });\n  });\n};\n\nmodule.exports = HappyWorker;\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/applyLoaders.js":"var HappyFakeLoaderContext = require('./HappyFakeLoaderContext');\nvar fnOncePedantic = require('./fnOncePedantic');\nvar assert = require('assert');\n\n/**\n * If this ain't a monster, I don't know what is.\n *\n *\n *               .'''''-,              ,-`````.\n *               `-.._  |              |  _..-'\n *                  \\    `,          ,'    /\n *                  '=   ,/          \\,   =`\n *                  '=   (            )   =`\n *                 .\\    /            \\    /.\n *                /  `,.'              `.,'  \\\n *                \\   `.                ,'   /\n *                 \\    \\              /    /\n *                  \\   .`.  __.---. ,`.   /\n *                   \\.' .'``        `. `./\n *                    \\.'  -'''-..     `./\n *                    /  /        '.      \\\n *                   /  / .--  .-'''`      '.\n *                  '   |    ,---.    _      \\\n *      /``-----._.-.   \\   / ,-. '-'   '.   .-._.-----``\\\n *      \\__ .     | :    `.' ((O))   ,-.  \\  : |     . __/\n *       `.  '-...\\_`     |   '-'   ((O)) |  '_/...-`  .'\n *  .----..)    `    \\     \\      /  '-'  / /    '    (..----.\n * (o      `.  /      \\     \\    /\\     .' /      \\  .'      o)\n *  ```---..   `.     /`.    '--'  '---' .'\\     .'   ..---```\n *          `-.  `.  /`.  `.           .' .'\\  .'  .-'\n *             `..` /   `.'  ` - - - ' `.'   \\ '..'\n *                 /    /                \\    \\\n *                /   ,'                  `.   \\\n *                \\  ,'`.                .'`.  /\n *                 `/    \\              /    \\'\n *                  ,=   (              )   =,\n *                  ,=   '\\            /`   =,\n *    LGB           /    .'            `.    \\\n *               .-'''  |                |  ```-.\n *               `......'                `......'\n *\n * @param {Object}            runContext\n * @param {HappyFakeCompiler} runContext.compiler\n * @param {Array.<Object>}    runContext.loaders\n * @param {Object}            runContext.loaderContext\n *\n * @param {String}            runContext.loaderContext.remoteLoaderId\n *        The ID of the HappyLoader instance that initiated this compilation\n *        request.\n *\n * @param {String}            runContext.loaderContext.request\n *        The full request for the resource including the loader chain string.\n *        Something like:\n *          '/path/to/style-loader.js!/path/to/css-loader.js!/path/to/resource.css'\n *\n * @param {String}            runContext.loaderContext.context\n *        The directory of the resource, useful for resolving siblings.\n *\n * @param {String}            runContext.loaderContext.resource\n *        The resource path without the loader chain. This includes the file\n *        and the query fragment.\n *\n * @param {String}            runContext.loaderContext.resourcePath\n *        The resource file.\n *\n * @param {String}            runContext.loaderContext.resourceQuery\n *        The resource query.\n *\n * @param {String}            sourceCode\n * @param {Object}            sourceMap\n *\n * @param {Function}          done\n * @param {String|Error}      done.err\n * @param {String}            done.sourceCode\n * @param {Object}            done.sourceMap\n */\nmodule.exports = function applyLoaders(runContext, sourceCode, sourceMap, done) {\n  assert(runContext.compiler, \"Missing webpack compiler instance!\");\n\n  // we start out by creating fake loader contexts for every loader\n  var loaders = runContext.loaders.map(function(loader) {\n    return {\n      request: loader.request,\n      path: loader.path,\n      query: loader.query,\n      module: require(loader.path),\n\n      // TODO: this is probably not the best place to create the context, and it\n      // also should be cached at some layer\n      context: HappyFakeLoaderContext({\n        _compiler: runContext.compiler, // for compiler RPCs\n        _remoteLoaderId: runContext.loaderContext.remoteLoaderId, // for loader RPCs\n        fs: runContext.compiler.inputFileSystem,\n\n        query: loader.query,\n        options: runContext.compiler.options,\n\n        request: runContext.loaderContext.request,\n        resource: runContext.loaderContext.resource,\n        resourcePath: runContext.loaderContext.resourcePath,\n        resourceQuery: runContext.loaderContext.resourceQuery,\n        context: runContext.loaderContext.context,\n\n        sourceMap: Boolean(runContext.loaderContext.useSourceMap),\n        target: runContext.loaderContext.target,\n      })\n    };\n  });\n\n  loaders.forEach(function exposeLoaderSetToEachLoader(loader, index) {\n    loader.context.loaders = loaders;\n    loader.context.loaderIndex = index;\n  });\n\n  // Go through the pitching phase. This might affect the loader contexts.\n  applyPitchLoaders(runContext.loaderContext.request, loaders, function(err, pitchResult) {\n    if (err) {\n      return done(err);\n    }\n\n    var apply = NormalLoaderApplier(loaders, pitchResult.dataMap, done);\n\n    // pitching phase did yield something so we skip the loaders to the right\n    // and use the yielded code as the starting sourceCode\n    if (pitchResult.sourceCode) {\n      apply(pitchResult.cursor - 1, pitchResult.sourceCode, pitchResult.sourceMap);\n    }\n    // otherwise, we just start from the right-most loader using the input\n    // source code and map:\n    else {\n      apply(loaders.length - 1, sourceCode, sourceMap);\n    }\n  });\n}\n\n// Perform the loader pitching phase.\n//\n// Pitching loaders are applied from left to right. Each loader is presented\n// with the request string disected into two bits; from the start until its\n// place in the string, then the remainder of the request.\n//\n// For example, for a request like the following:\n//\n//     \"c!b!a!./foo.js\"\n//\n// The run order will be like the following with the inputs outlined at each\n// application step:\n//\n// 1. Loader \"c\"\n//\n//     [remainingRequest] => \"b!a!./foo.js\"\n//     [precedingRequest] => \"\"\n//\n// 2. Loader \"b\"\n//\n//     [remainingRequest] => \"a!./foo.js\"\n//     [precedingRequest] => \"c\"\n//\n// 2. Loader \"a\"\n//\n//     [remainingRequest] => \"./foo.js\"\n//     [precedingRequest] => \"c!b\"\n//\n// Finally, it is also presented with a special \"data\" state variable that will\n// be shared between the pitch and normal phases for **that specific loader**.\n//\n// For example:\n//\n//     module.exports = function() {\n//       console.log(this.data.value); // => 42\n//     };\n//\n//     module.exports.pitch = function(_, _, data) {\n//       data.value = 42;\n//     };\n//\nfunction applyPitchLoaders(request, loaders, done) {\n  var requestFragments = request.split(/\\!/g);\n\n  (function applyPitchLoader(cursor, dataMap) {\n    var loader = loaders[cursor];\n\n    if (!loader) {\n      return done(null, {\n        cursor: null,\n        sourceCode: null,\n        sourceMap: null,\n        dataMap: dataMap,\n      });\n    }\n    else if (!loader.module.pitch) {\n      return applyPitchLoader(cursor + 1, dataMap);\n    }\n    else {\n      // pitch loader, when applied, may modify any of these context variables:\n      //\n      // - this.resourcePath\n      // - this.resourceQuery\n      // - this.resource\n      // - this.loaderIndex (TODO: why would this be modified? does it affect the run order?!)\n      applySyncOrAsync(loader.module.pitch, loader.context, [\n        requestFragments.slice(cursor+1).join('!'),\n        requestFragments.slice(0, cursor).join('!'),\n        dataMap[cursor]\n      ], function(err, sourceCode, sourceMap) {\n        if (err) {\n          done(err);\n        }\n        else if (sourceCode) {\n          done(null, {\n            cursor: cursor,\n            sourceCode: sourceCode,\n            sourceMap: sourceMap,\n            dataMap: dataMap,\n          });\n        }\n        else {\n          applyPitchLoader(cursor + 1, dataMap);\n        }\n      });\n    }\n  }(0, loaders.map(function() { return {}; })));\n}\n\n// Generates a function that will perform the \"normal\" loader phase (ie\n// non-pitching.)\n//\n// Normal loaders are applied from right-to-left and may yield one or both of\n// \"sourceCode\" and \"sourceMap\" values.\n//\n// Each application will forward a state variable called \"inputValues\" to the\n// succeeding loader, which gets populated as \"values\" in the preceding one.\n//\n// For example, for a request like this \"b!a!./foo.js\"\n//\n//     // a-loader.js\n//     module.exports = function(code) {\n//       this.values = { foo: 'bar' };\n//\n//       return code;\n//     };\n//\n//     // b-loader.js\n//     module.exports = function(code) {\n//       console.log(this.inputValues); // { foo: \"bar\" };\n//\n//       return code;\n//     };\n//\n// @param {Array.<Object>} dataMap\n//        Data generated during the pitching phase. This set is expected to be\n//        fully populated (even if each item is an empty object) and be ordered\n//        after the loaders in the @loaders array.\n//\nfunction NormalLoaderApplier(loaders, dataMap, done) {\n  return function apply(cursor, sourceCode, sourceMap, inputValues) {\n    var loader = loaders[cursor];\n    var context;\n\n    if (!loader) {\n      return done(null, sourceCode, sourceMap);\n    }\n\n    context = loader.context;\n    context.data = dataMap[cursor];\n    context.inputValues = inputValues || {};\n\n    applySyncOrAsync(loader.module, context, [ sourceCode, sourceMap ],\n      function(err, nextSource, nextSourceMap) {\n        if (err) {\n          return done(err);\n        }\n\n        apply(cursor - 1, nextSource, nextSourceMap, context.values);\n      }\n    );\n  };\n}\n\n// Utility function for applying a function and accepting a result in one of\n// three ways:\n//\n// - a synchronous return, where only one value may be yielded\n// - a multi-value yield using a generated `this.callback(...)` callback\n// - a multi-value yield that is also asynchronous using `callback = this.async();`\n//\n// @done will always be called with {String|Error, ...} for an error and the\n// yielded values.\n//\n// Example victims:\n//\n// 1. Synchronous, single-yield:\n//\n//     function() {\n//       return 'hello!';\n//     }\n//\n// 2. Synchronous, multi-yield:\n//\n//     function() {\n//       this.callback(null, 'hello', 'world!');\n//     }\n//\n// 3. Asynchronous, single-yield:\n//\n//     function() {\n//       var callback = this.async();\n//\n//       setTimeout(function() {\n//         callback(null, 'hello');\n//       }, 1000);\n//     }\n//\n// 4. Asynchronous, multi-yield:\n//\n//     function() {\n//       var callback = this.async();\n//\n//       setTimeout(function() {\n//         callback(null, 'hello', 'world!');\n//       }, 1000);\n//     }\nfunction applySyncOrAsync(fn, context, args, done) {\n  var expectSynchronousResponse = true;\n\n  // sync/async this.callback() style\n  context.callback = fnOncePedantic(function() {\n    expectSynchronousResponse = false;\n\n    return done.apply(null, arguments);\n  }, \"this.callback(): The callback was already called.\");\n\n  context.async = fnOncePedantic(function() {\n    expectSynchronousResponse = false;\n\n    return done;\n  }, \"this.async(): The callback was already called.\");\n\n  try {\n    // synchronus return style\n    var result = fn.apply(context, args);\n\n    if (expectSynchronousResponse) {\n      if (result) {\n        done(null, result);\n      }\n      else {\n        done();\n      }\n    }\n  }\n  catch(e) { // abort the chain\n    done(e);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyFakeLoaderContext.js":"var resolveSyncNotSupported = NotSupported('this.resolveSync()');\nvar execNotSupported = NotSupported('this.exec()');\n\nfunction HappyFakeLoaderContext(initialValues) {\n  var loader = {};\n\n  // for compiler RPCs, like this.resolve()\n  loader._compiler = null;\n\n  // for loader RPCs, like this.emitWarning()\n  loader._remoteLoaderId = null;\n\n  loader.version = 1; // https://webpack.github.io/docs/loaders.html#version\n  loader.webpack = false;\n  loader.request = null;\n  loader.query = null;\n\n  loader.context = null;\n  loader.resource = null;\n  loader.resourcePath = null;\n  loader.resourceQuery = null;\n\n  loader.data = {};\n  loader.loaders = [{}];\n  loader.loaderIndex = 0;\n\n  loader.options = null; // TODO: we should read this from compiler options\n  loader.result = null;\n\n  loader.sourceMap = false;\n  loader.fs = null;\n  loader.target = 'web';\n\n  // TODO\n  loader.cacheable = function() {};\n  loader.callback = null; // will be defined at runtime\n  loader.async = null; // will be defined at runtime\n\n  loader.exec = execNotSupported;\n\n  loader.emitWarning = function(message) {\n    loader._compiler._sendMessage('emitWarning', {\n      remoteLoaderId: loader._remoteLoaderId,\n      message: message\n    });\n  };\n\n  loader.emitError = function(message) {\n    loader._compiler._sendMessage('emitError', {\n      remoteLoaderId: loader._remoteLoaderId,\n      message: message\n    });\n  };\n\n  loader.resolve = function(context, resource, done) {\n    loader._compiler.resolve(context, resource, done);\n  };\n\n  loader.resolveSync = resolveSyncNotSupported;\n\n  loader.addDependency = function(file) {\n    loader._compiler._sendMessage('addDependency', {\n      remoteLoaderId: loader._remoteLoaderId,\n      file: file\n    });\n  };\n\n  loader.addContextDependency = function(file) {\n    loader._compiler._sendMessage('addContextDependency', {\n      remoteLoaderId: loader._remoteLoaderId,\n      file: file\n    });\n  };\n\n  loader.clearDependencies = function() {\n    loader._compiler._sendMessage('clearDependencies', {\n      remoteLoaderId: loader._remoteLoaderId\n    });\n  };\n\n  loader.emitFile = function(name, contents, sourceMap) {\n    loader._compiler._sendMessage('emitFile', {\n      remoteLoaderId: loader._remoteLoaderId,\n      name: name,\n      contents: contents,\n      sourceMap: JSON.stringify(sourceMap || {})\n    });\n  };\n\n  loader.loadModule = function(resource, done) {\n    loader._compiler._sendMessage('loadModule', {\n      remoteLoaderId: loader._remoteLoaderId,\n      file: resource,\n    }, done);\n  };\n\n  // alias\n  loader.dependency = loader.addDependency;\n\n  Object.keys(initialValues || {}).forEach(function(key) {\n    if (!loader.hasOwnProperty(key)) {\n      console.warn('Unrecognized fake loader context attribute \"%s\".', key);\n    }\n\n    loader[key] = initialValues[key];\n  });\n\n  return loader;\n}\n\nfunction NotSupported(fnName) {\n  return function() {\n    throw new Error('HappyPack: ' + fnName + ' is not supported for happy loaders.');\n  };\n}\nmodule.exports = HappyFakeLoaderContext;\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/fnOncePedantic.js":"module.exports = function OncePedantic(fn, errorMessage) {\n  var called = false;\n\n  return function() {\n    if (called) {\n      throw new Error(errorMessage);\n    }\n\n    called = true;\n    return fn.apply(null, arguments);\n  }\n};","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/serializeError.js":"module.exports = function(error) {\n  var buf = [];\n\n  if (error.hasOwnProperty('message')) {\n    buf.push(error.message);\n  }\n\n  if (error.hasOwnProperty('stack')) {\n    buf.push(error.stack);\n  }\n\n  if (!buf.length) {\n    buf.push(JSON.stringify(error));\n  }\n\n  return buf.join('\\n');\n};","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyFSCache.js":"var fs = require('fs');\nvar Utils = require('./HappyUtils');\nvar assert = require('assert');\n\n/**\n * @param {Object} config\n * @param {String} config.id\n *        HappyPack Plugin ID, for logging purposes.\n *\n * @param {Boolean} config.verbose\n * @param {Function?} config.generateSignature\n * @param {String} config.path\n *        Absolute path to where the JSON representation of the cache should\n *        be stored. Path must be writable.\n *\n */\nmodule.exports = function HappyFSCache(config) {\n  var exports = {};\n  var id = config.id;\n  var cachePath = config.path;\n  var cache = { context: {}, mtimes: {} };\n  var generateSignature = config.generateSignature || getMTime;\n\n  assert(typeof cachePath === 'string',\n    \"HappyFSCache requires a @path parameter that points to where it will be stored.\");\n\n /**\n  * @param {Object} params.context\n  *        An object that should fully represent the context in which the plugin\n  *        was run. This object will be used to determine whether previous cache\n  *        entries are still valid or not.\n  *\n  *        This MUST be JSON-serializable!\n  *\n  * @return {Boolean}\n  *         Whether the cache was loaded from disk.\n  */\n  exports.load = function(currentContext) {\n    var oldCache, staleEntryCount;\n\n    cache.context = currentContext;\n\n    assert(typeof currentContext === 'object' && !!currentContext,\n      \"HappyFSCache requires a @context parameter to work.\");\n\n    if (!Utils.isReadable(cachePath)) {\n      if (config.verbose) {\n        console.log('Happy[%s]: No cache was found, starting fresh.', id);\n      }\n\n      return false;\n    }\n\n    try {\n      oldCache = JSON.parse(fs.readFileSync(cachePath, 'utf-8'));\n    } catch(e) {\n      oldCache = null;\n    }\n\n    if (!oldCache || toJSON(oldCache.context) !== toJSON(currentContext)) {\n      if (config.verbose) {\n        console.log('Happy[%s]: Cache is no longer valid, starting fresh.', id);\n      }\n\n      return false;\n    }\n\n    cache.mtimes = oldCache.mtimes;\n    cache.context = currentContext;\n\n    staleEntryCount = removeStaleEntries(cache.mtimes, generateSignature);\n\n    if (config.verbose) {\n      console.log('Happy[%s]: Loaded %d entries from cache. (%d were stale)',\n        id,\n        Object.keys(cache.mtimes).length,\n        staleEntryCount\n      );\n    }\n\n    return true;\n  };\n\n  exports.save = function() {\n    fs.writeFileSync(cachePath, JSON.stringify(cache));\n  };\n\n  exports.getCompiledSourceCodePath = function(filePath) {\n    return cache.mtimes[filePath] && cache.mtimes[filePath].compiledPath;\n  };\n\n  exports.getCompiledSourceMapPath = function(filePath) {\n    return cache.mtimes[filePath] && cache.mtimes[filePath].compiledPath + '.map';\n  };\n\n  exports.hasChanged = function(filePath) {\n    var nowMTime = generateSignature(filePath);\n    var lastMTime = getSignatureAtCompilationTime(filePath);\n\n    return nowMTime !== lastMTime;\n  };\n\n  exports.hasErrored = function(filePath) {\n    return cache.mtimes[filePath] && cache.mtimes[filePath].error;\n  };\n\n  exports.invalidateEntryFor = function(filePath) {\n    delete cache.mtimes[filePath];\n  };\n\n  exports.set = function(filePath, error, compiledPath) {\n    cache.mtimes[filePath] = {\n      mtime: generateSignature(filePath),\n      compiledPath: compiledPath,\n      error: error\n    };\n  };\n\n  exports.dump = function() {\n    return cache;\n  };\n\n  function getSignatureAtCompilationTime(filePath) {\n    if (cache.mtimes[filePath]) {\n      return cache.mtimes[filePath].mtime;\n    }\n  }\n\n  return exports;\n}\n\nfunction toJSON(object) {\n  return JSON.stringify(object);\n}\n\nfunction getMTime(filePath) {\n  try {\n    return fs.statSync(filePath).mtime.getTime();\n  }\n  catch (e) {\n    return -1;\n  }\n}\n\nfunction removeStaleEntries(mtimes, generateSignature) {\n  return Object.keys(mtimes).reduce(function(acc, filePath) {\n    var entry = mtimes[filePath];\n\n    if (isStale(entry, filePath)) {\n      delete mtimes[filePath];\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  function isStale(entry, filePath) {\n    return (\n      // was the source removed?\n      !Utils.isReadable(filePath)\n      // was the compiled version removed or never created?\n      || !Utils.isReadable(entry.compiledPath)\n      // has source been modified since we last compiled it?\n      || entry.mtime !== generateSignature(filePath)\n    );\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyUtils.js":"var fs = require('fs');\nvar mkdirp = require('mkdirp');\nvar accessFile = fs.accessSync || fs.existsSync;\n\nexports.generateCompiledPath = function(filePath) {\n  return 's-' + hashString(filePath + Math.random().toString(36).substr(2));\n};\n\nexports.isReadable = function(filePath) {\n  try {\n    var ret = accessFile(filePath, fs.R_OK);\n    if (ret !== undefined) {\n      return ret;\n    }\n    return true;\n  }\n  catch(e) {\n    return false;\n  }\n};\n\nexports.mkdirSync = function(dirPath) {\n  try {\n    mkdirp.sync(dirPath);\n  }\n  catch (e) {\n    if (!e.message.match('EEXIST')) {\n      throw e;\n    }\n  }\n};\n\n// Courtesy of http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\nfunction hashString(string) {\n  var hash = 0;\n  var i, chr, len;\n\n  if (string.length === 0) return hash;\n\n  for (i = 0, len = string.length; i < len; i++) {\n    chr   = string.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return String(hash);\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/WebpackUtils.js":"var async = require('async');\nvar assert = require('assert');\n\nexports.normalizeLoader = function(input) {\n  var normals;\n\n  // happypack variant:\n  if (typeof input === 'object' && input.hasOwnProperty('path')) {\n    normals = [ objectAssign({}, input) ];\n  }\n  // webpack object variant:\n  else if (typeof input === 'object') {\n    normals = [].concat(exports.extractLoaders(input));\n  }\n  // webpack/happypack string loader(s):\n  else if (typeof input === 'string') {\n    normals = [].concat(extractPathAndQueryFromString(input));\n  }\n\n  return normals.map(function(loader) {\n    // normalize the query so that it is always a string prefixed by '?'\n    if (loader.query) {\n      if (typeof loader.query === 'object') {\n        loader.query = '?' + JSON.stringify(loader.query);\n      }\n      else if (typeof loader.query === 'string') {\n        loader.query = ensureHasLeadingMarker(loader.query);\n      }\n    }\n\n    // be compatible with webpack's syntax within our own: if they specify\n    // a loader's path using a \"loader\" attribute, map it to the \"path\" one\n    if (loader.loader) {\n      loader.path = loader.loader;\n      delete loader.loader;\n    }\n\n    return loader;\n  });\n};\n\n/**\n * Extract the set of loaders (one or more) from a given a \"module.loaders\"\n * webpack config entry.\n *\n * This does NOT perform any normalization on the query, so the query may be\n * a string (prefixed by '?' or not) or it may be an object.\n *\n * Example inputs/outputs:\n *\n *     // a loader chain\n *     {\n *       loaders: [ 'style', 'css' ]\n *     }\n *     // => [ \"style\", \"css\" ]\n *\n *     // another loader chain\n *     {\n *       loaders: [ 'style!css' ]\n *     }\n *     // => [ \"style!css\" ]\n *\n *     // a single loader, no query:\n *     {\n *       loader: 'babel'\n *     }\n *     // => [ \"babel\" ]\n *\n *     // a single loader with inline query:\n *     {\n *       loader: 'babel?presets[]=react'\n *     }\n *     // => [ \"babel?presets[]=react\" ]\n *\n *     // a single loader with a query object:\n *     {\n *       loader: 'babel',\n *       query: { presets: [ 'react' ] }\n *     }\n *     // => [ \"babel?presets[]=react\" ]\n *\n *     // webpack 2: multiple loaders with object / string combinations:\n *     {\n *       loaders: [\n *         'react-hot',\n *         { loader: 'babel', query: { presets: [ 'react' ] } },\n *       ]\n *     }\n *\n * @param  {Object|String} entry\n * @param  {?Array.<String|Object>} entry.loaders\n * @param  {!String} entry.loader\n * @param  {?Object|String} entry.query\n *\n * @return {Object|Array.<Object>}\n */\nexports.extractLoaders = function extractLoaders(entry) {\n  if (typeof entry === 'object' && entry.loaders) {\n    return entry.loaders.reduce(function(list, loader) {\n      return list.concat(extractLoaders(loader));\n    }, []);\n  }\n  else if (typeof entry === 'string') {\n    return extractPathAndQueryFromString(entry);\n  }\n  else if (typeof entry.loader === 'string' && entry.query) {\n    return { path: entry.loader, query: entry.query };\n  }\n  else if (typeof entry.loader === 'string' && entry.options) {\n    return { path: entry.loader, query: '?' + JSON.stringify(entry.options) };\n  }\n  else if (typeof entry.loader === 'string') {\n    return extractPathAndQueryFromString(entry.loader);\n  }\n  else {\n    console.error(entry);\n    assert(false, \"HappyPack: Unrecognized loader configuration variant!\");\n  }\n};\n\nexports.resolveLoaders = function(compiler, loaders, done) {\n  var resolve = compiler.resolvers.loader.resolve;\n  var resolveContext = compiler.resolvers.loader;\n\n  // webpack2 has changed the signature for the resolve method where it accepts\n  // a fourth argument (context), so we need to sniff and support both versions\n  //\n  // fixes #23\n  var isWebpack2 = resolve.length === 4;\n\n  async.parallel(loaders.map(function(loader) {\n    assert(!!loader, \"Invalid loader string to resolve!!! \" + JSON.stringify(loaders));\n\n    return function(callback) {\n      var callArgs = [ compiler.context, loader, function(err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, result);\n      }];\n\n      if (isWebpack2) {\n        resolve.apply(resolveContext, [ compiler.context ].concat(callArgs));\n      }\n      else {\n        resolve.apply(resolveContext, callArgs);\n      }\n    };\n  }), done);\n};\n\nexports.applyLoaders = require('./applyLoaders');\n\nfunction extractPathAndQueryFromString(string) {\n  var loaders = string.split('!');\n\n  if (loaders.length > 1) {\n    return loaders.map(extractPathAndQueryFromString);\n  }\n\n  var loaderString = loaders[0];\n  var fragments = loaderString.split('?');\n\n  if (fragments.length === 1) {\n    return { path: loaderString };\n  }\n\n  return { path: fragments[0], query: '?' + fragments[1] };\n}\n\nfunction ensureHasLeadingMarker(queryString) {\n  return queryString[0] === '?' ? queryString : ('?' + queryString);\n}\n\nfunction objectAssign(target) {\n  var sources = [].slice.call(arguments, 1);\n\n  return sources.reduce(function(map, source) {\n    Object.keys(source).forEach(function(key) {\n      map[key] = source[key];\n    });\n\n    return map;\n  }, target);\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/OptionParser.js":"var assert = require('assert');\n\nmodule.exports = function parseAndValidateOptions(params, schema, displayName) {\n  // ensure required parameters are passed in\n  Object.keys(schema)\n    .filter(function(key) {\n      if (schema[key].isRequired instanceof Function) {\n        return schema[key].isRequired();\n      }\n      return schema[key].isRequired;\n    })\n    .forEach(function(key) {\n      assert(params.hasOwnProperty(key),\n        format(\"Missing required parameter '\" + key + \"'\")\n      );\n    })\n  ;\n\n  return Object.keys(params).reduce(function(hsh, key) {\n    var spec = schema[key];\n    var value = params[key];\n    var validationError;\n\n    assert(schema.hasOwnProperty(key),\n      format(\"Unrecognized option '\" + key + \"'\")\n    );\n\n    if (spec.validate) {\n      validationError = spec.validate(value);\n\n      assert(!validationError, format(validationError));\n    }\n\n    if (spec.type) {\n      assert(typeof value === spec.type,\n        format(\"Option '\" + key + \"' must be of type '\" + spec.type + \"' not '\" + typeof value + \"'.\")\n      );\n    }\n\n    if (spec.default && (value === undefined || value === null)) {\n      hsh[key] = spec.default;\n    }\n    else {\n      hsh[key] = value;\n    }\n\n    return hsh;\n  }, getDefaults());\n\n  function getDefaults() {\n    return Object.keys(schema).reduce(function(hsh, key) {\n      if (schema[key].default) {\n        hsh[key] = schema[key].default;\n      }\n\n      return hsh;\n    }, {});\n  }\n\n  function format(message) {\n    return displayName + \": \" + message;\n  }\n};","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/JSONSerializer.js":"/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n// Adapted from https://github.com/yahoo/serialize-javascript so that it is\n// deserializable as well and doesn't care about functions.\n\nvar isRegExp = require('util').isRegExp;\nvar stringify = require('json-stringify-safe');\n\nvar PLACE_HOLDER_REGEXP = new RegExp('\"@__(REGEXP){(\\\\d+)}@\"', 'g');\n\nvar UNSAFE_CHARS_REGEXP = /[<>\\/\\u2028\\u2029]/g;\n\n// Mapping of unsafe HTML and invalid JavaScript line terminator chars to their\n// Unicode char counterparts which are safe to use in JavaScript strings.\nvar UNICODE_CHARS = {\n  '<'     : '\\\\u003C',\n  '>'     : '\\\\u003E',\n  '/'     : '\\\\u002F',\n  '\\u2028': '\\\\u2028',\n  '\\u2029': '\\\\u2029'\n};\n\nexports.serialize = function(obj) {\n  var regexps   = [];\n  var str;\n\n  // Creates a JSON string representation of the object and uses placeholders\n  // for functions and regexps (identified by index) which are later\n  // replaced.\n  str = stringify(obj, function (key, value) {\n    if (typeof value === 'object' && isRegExp(value)) {\n      return '@__REGEXP{' + (regexps.push(value) - 1) + '}@';\n    }\n\n    return value;\n  });\n\n  // Protects against `JSON.stringify()` returning `undefined`, by serializing\n  // to the literal string: \"undefined\".\n  if (typeof str !== 'string') {\n    return String(str);\n  }\n\n  // Replace unsafe HTML and invalid JavaScript line terminator chars with\n  // their safe Unicode char counterpart. This _must_ happen before the\n  // regexps and functions are serialized and added back to the string.\n  str = str.replace(UNSAFE_CHARS_REGEXP, function (unsafeChar) {\n    return UNICODE_CHARS[unsafeChar];\n  });\n\n  if (regexps.length === 0) {\n    return str;\n  }\n\n  // Replaces all occurrences of function and regexp placeholders in the JSON\n  // string with their string representations. If the original value can not\n  // be found, then `undefined` is used.\n  return str.replace(PLACE_HOLDER_REGEXP, function (match, type, valueIndex) {\n    if (type === 'REGEXP') {\n      return JSON.stringify(serializeRegExp(regexps[valueIndex]));\n    }\n\n    return match;\n  }, 0, function() {});\n}\n\nexports.deserialize = function(string) {\n  return JSON.parse(string, function(key, value) {\n    if (Array.isArray(value) && value.length === 3 && value[0] === '@__REGEXP') {\n      return new RegExp(value[1], value[2]);\n    }\n\n    return value;\n  });\n};\n\nfunction serializeRegExp(regex) {\n  var flags = '';\n\n  if (regex.global) flags += 'g';\n  if (regex.ignoreCase) flags += 'i';\n  if (regex.multiline) flags += 'm';\n  if (regex.sticky) flags += 'y';\n  if (regex.unicode) flags += 'u';\n\n  return ['@__REGEXP', regex.source, flags];\n}","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/loader.js":"module.exports = require('./lib/HappyLoader');","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyLoader.js":"var assert = require('assert');\nvar loaderUtils = require('loader-utils');\nvar DEFAULT_COMPILER_ID = 'default';\nvar DEFAULT_LOADER_ID = '1';\n\nfunction HappyLoader(sourceCode, sourceMap) {\n  var query, compilerId, loaderId, remoteLoaderId, happyPlugin;\n  var callback = this.async();\n  var pluginList;\n\n  assert(callback, \"HappyPack only works when asynchronous loaders are allowed!\");\n\n  this.cacheable();\n\n  if (Array.isArray(this.options.plugins)) {\n    pluginList = this.options.plugins;\n  }\n  else if (typeof this.options.plugins === 'function') {\n    pluginList = this.options.plugins();\n  }\n  else if (!this.options.plugins && this._compiler && this._compiler.options && this._compiler.options.plugins) {\n    pluginList = this._compiler.options.plugins;\n  }\n\n  query = loaderUtils.parseQuery(this.query);\n  compilerId = query.compilerId || DEFAULT_COMPILER_ID;\n  loaderId = query.id || DEFAULT_LOADER_ID;\n  remoteLoaderId = 'Loader::' + compilerId + loaderId.toString() + ':' + this.resource;\n\n  assert(pluginList && Array.isArray(pluginList),\n    \"HappyPack: unable to locate the plugin list, this most likely indicates \" +\n    \"an internal error!\"\n  );\n\n  happyPlugin = pluginList.filter(isHappy(loaderId))[0];\n\n  assert(!!happyPlugin,\n    \"HappyPack: plugin for the loader '\" + loaderId + \"' could not be found! \" +\n    \"Did you forget to add it to the plugin list?\"\n  );\n\n  happyPlugin.compile(this, {\n    remoteLoaderId: remoteLoaderId,\n    compilerId: compilerId,\n    sourceCode: sourceCode,\n    sourceMap: sourceMap,\n\n    useSourceMap: this._module.useSourceMap,\n\n    // TODO: maybe too much data being pushed down the drain here? we can infer\n    // all of this from `this.request`\n    context: this.context,\n    request: happyPlugin.generateRequest(this.resource),\n    resource: this.resource,\n    resourcePath: this.resourcePath,\n    resourceQuery: this.resourceQuery,\n    target: this.target,\n  }, callback);\n}\n\nmodule.exports = HappyLoader;\n\nfunction isHappy(id) {\n  return function(plugin) {\n    return plugin.name === 'HappyPack' && plugin.id === id;\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyMessage.js":"// READY\n//\n// Emitted when a channel is open and ready to accept further messages.\n//\n//     shape({});\n\n// CONFIGURE\n//\n// Emitted by each HappyThread to its channel with the current compiler's\n// options so that the workers may use those options in their FakeCompiler /\n// FakeLoaderContext.\n//\n//     shape({\n//       data: shape({\n//         compilerOptions: string\n//       })\n//     });\n\n// CONFIGURE_DONE\n//\n// Emitted when a channel has successfully deserialized and configured its\n// workers with the compiler options.\n//\n//     shape({});\n\n// COMPILE\n//\n//     shape({\n//       id: string.isRequired,\n//       sourcePath: string,\n//       compiledPath: string,\n//       loaderContext: object,\n//     });\n\n// COMPILE_DONE\n//\n//     shape({\n//       id: string.isRequired,\n//       sourcePath: string,\n//       compiledPath: string,\n//       success: bool,\n//     });\n\n// COMPILER_REQUEST\n//\n//     shape({\n//       id: string.isRequired,\n//       data: shape({\n//         type: oneOf([ 'resolve' ]).isRequired,\n//\n//         payload: oneOfType([\n//           // resolve\n//           shape({\n//             context: string,\n//             resource: string,\n//           }),\n//         ]).isRequired,\n//       }),\n//     });\n\n// COMPILER_RESPONSE\n//\n//     shape({\n//       id: string.isRequired,\n//       data: shape({\n//         payload: shape({\n//           error: string,\n//           result: object,\n//         })\n//       })\n//     });\n","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyTestUtils.js":"var path = require('path');\nvar fs = require('fs-extra');\nvar sinon = require('sinon');\nvar chai = require('chai');\nvar multiline = require('multiline-slash');\nvar HappyRPCHandler = require('./HappyRPCHandler');\nvar CACHE_DIR = path.resolve(__dirname, '../.happypack');\nvar cleanups = [];\nvar gid = 0;\n\nsinon.assert.expose(chai.assert, { prefix: \"\" });\n\nafterEach(function() {\n  cleanups.forEach(function(callback) {\n    callback();\n  });\n\n  cleanups = [];\n});\n\nexports.HAPPY_LOADER_PATH = path.resolve(__dirname, 'HappyLoader.js');\nexports.assert = chai.assert;\nexports.fixturePath = function(fileName) {\n  return path.resolve(__dirname, '__tests__', 'fixtures', fileName);\n};\n\nexports.fixture = function(fileName) {\n  return fs.readFileSync(exports.fixturePath(fileName), 'utf-8');\n};\n\nexports.assertNoWebpackErrors = function(err, rawStats, done) {\n  if (err) {\n    done(err);\n    return true;\n  }\n\n  var stats = rawStats.toJson();\n\n  if (stats.errors.length) {\n    done(stats.errors);\n    return true;\n  }\n\n  if (stats.warnings.length) {\n    done(stats.warnings);\n    return true;\n  }\n};\n\n// courtesy of http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n    s4() + '-' + s4() + s4() + s4();\n}\n\nfunction interpolateGUID(string) {\n  return string\n    .replace(/\\[guid\\]/g, function() {\n      return guid();\n    }).replace(/\\[gid\\]/g, function() {\n      return ++gid;\n    })\n  ;\n}\n\n/**\n * @module TestUtils.IntegrationSuite\n *\n * @param {mocha} mochaSuite\n * @param {Object} suiteOptions\n * @param {Number} [suiteOptions.timeout=2000]\n */\nfunction IntegrationSuite2(mochaSuite, suiteOptions) {\n  var sandbox;\n  var testSuite = {};\n  var suiteRoot = interpolateGUID(path.join(__dirname, '../tmp/test-repo__[gid]-[guid]'));\n\n  suiteOptions = suiteOptions || {};\n\n  var timeout = process.env.HAPPY_TEST_TIMEOUT ?\n    parseInt(process.env.HAPPY_TEST_TIMEOUT, 10) :\n    suiteOptions.timeout || 2000\n  ;\n\n  mochaSuite.timeout(timeout);\n\n  mochaSuite.beforeEach(function() {\n    fs.removeSync(CACHE_DIR);\n    fs.ensureDirSync(suiteRoot);\n  });\n\n  mochaSuite.afterEach(function() {\n    if (sandbox) {\n      sandbox.restore();\n      sandbox = null;\n    }\n\n    fs.removeSync(CACHE_DIR);\n\n    if (process.env.HAPPY_TEST_ARTIFACTS !== '1') {\n      fs.removeSync(suiteRoot);\n    }\n  });\n\n  /**\n   * Create a temporary file.\n   *\n   * @param  {String} fileName\n   *         Relative file path.\n   *\n   * @param  {String|Function} contentsFn\n   *         The contents of the file. If it's a function, we'll multiline-slash\n   *         it.\n   *\n   * @return {Object} file\n   * @return {String} file.path\n   * @return {String} file.contents\n   */\n  testSuite.createFile = function(fileName, contentsFn) {\n    var filePath = path.join(suiteRoot, fileName || '~file-[gid]');\n    var contents = contentsFn instanceof Function ? multiline(contentsFn) : contentsFn;\n\n    fs.ensureDirSync(path.dirname(filePath));\n    fs.writeFileSync(filePath, contents, 'utf-8');\n\n    return { path: filePath, contents: contents };\n  };\n\n  testSuite.createDirectory = function(fileName) {\n    var filePath = path.join(suiteRoot, fileName);\n\n    fs.ensureDirSync(filePath);\n\n    return { path: filePath };\n  };\n\n  testSuite.resolve = function() {\n    return path.join.apply(path, [ suiteRoot ].concat([].slice.call(arguments)));\n  };\n\n  testSuite.getSinonSandbox = function() {\n    if (!sandbox) {\n      sandbox = sinon.sandbox.create({ useFakeTimers: false, useFakeServer: false });\n    }\n\n    return sandbox;\n  };\n\n  testSuite.createLoader = function(impl, query) {\n    return testSuite.createLoaderFromString('module.exports = ' + impl.toString(), query);\n  };\n\n  testSuite.createLoaderFromString = function(string, query) {\n    var loaderName = interpolateGUID('auto-generated-[gid]');\n    var filePath = testSuite.resolve(loaderName + '-loader.js');\n\n    fs.writeFileSync(filePath, string, 'utf-8');\n\n    return { _name: loaderName, path: filePath, query: query };\n  };\n\n  // Listen for HappyLoader instances registering themselves to HappyRPCHandler,\n  // grab that instance, and yield it so that you can install your spies and such.\n  //\n  // @return {Function}\n  //   Returns the latest active loader instance, if any.\n  testSuite.spyOnActiveLoader = function(fn) {\n    var registerActiveLoader = HappyRPCHandler.prototype.registerActiveLoader;\n    var happyLoader;\n\n    sandbox.stub(HappyRPCHandler.prototype, 'registerActiveLoader', function(id, loader) {\n      happyLoader = loader;\n\n      if (fn) {\n        fn(happyLoader);\n      }\n\n      return registerActiveLoader.apply(this, arguments);\n    });\n\n    Object.defineProperty(testSuite, 'activeLoader', {\n      configurable: true,\n      enumerable: false,\n      get: function() {\n        return happyLoader;\n      }\n    });\n\n    cleanups.push(function() {\n      happyLoader = null;\n    });\n\n    return function() { return happyLoader; };\n  };\n\n  return testSuite;\n};\n\nexports.IntegrationSuite2 = IntegrationSuite2;","/home/travis/build/npmtest/node-npmtest-happypack/node_modules/happypack/lib/HappyWorkerChannel.js":"#!/usr/bin/env node\n\nvar JSONSerializer = require('./JSONSerializer');\nvar HappyFakeCompiler = require('./HappyFakeCompiler');\nvar HappyWorker = require('./HappyWorker');\n\nif (process.argv[1] === __filename) {\n  startAsWorker();\n}\n\nfunction startAsWorker() {\n  HappyWorkerChannel(String(process.argv[2]), process);\n}\n\nfunction HappyWorkerChannel(id, stream) {\n  var fakeCompilers = {};\n  var workers = {};\n  var handlers = {\n    CONFIGURE: function(message) {\n      findOrCreateFakeCompiler(message.data.compilerId)\n        .configure(JSONSerializer.deserialize(message.data.compilerOptions))\n      ;\n\n      stream.send({\n        id: message.id,\n        name: 'CONFIGURE_DONE'\n      });\n    },\n\n    COMPILE: function(message) {\n      getWorker(message.data.loaderContext.compilerId)\n        .compile(message.data, function(result) {\n          stream.send({\n            id: message.id,\n            name: 'COMPILED',\n            sourcePath: result.sourcePath,\n            compiledPath: result.compiledPath,\n            success: result.success\n          });\n        })\n      ;\n    },\n\n    COMPILER_RESPONSE: function(message) {\n      getFakeCompiler(message.data.compilerId)\n        ._handleResponse(message.id, message.data)\n      ;\n    },\n  };\n\n  stream.on('message', accept);\n  stream.send({ name: 'READY' });\n\n  function accept(message) {\n    var handler = handlers[message.name];\n\n    if (!handler) {\n      console.warn('ignoring unknown message:', message);\n    }\n    else {\n      handler(message);\n    }\n  }\n\n  function getFakeCompiler(compilerId) {\n    return fakeCompilers[compilerId];\n  }\n\n  function getWorker(compilerId) {\n    return workers[compilerId];\n  }\n\n  function findOrCreateFakeCompiler(compilerId) {\n    if (!fakeCompilers[compilerId]) {\n      fakeCompilers[compilerId] = new HappyFakeCompiler({\n        id: id,\n        compilerId: compilerId,\n        send: stream.send.bind(stream)\n      });\n\n      workers[compilerId] = new HappyWorker({\n        compiler: fakeCompilers[compilerId]\n      });\n    }\n\n    return fakeCompilers[compilerId];\n  }\n}\n\nmodule.exports = HappyWorkerChannel;"}